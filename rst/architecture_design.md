这是一个典型的“高并发+强一致性”的金融秒杀场景。针对你的需求，我将按照你要求的思维步骤，为你设计一套防御性架构。

### 1. 【场景分析】
*   **流量特征**：5万并发（QPS）对于互联网大厂是中等规模，但对于涉及资金交易的金融系统是巨大的冲击。
*   **业务特征**：
    *   **瞬时脉冲**：流量在 9:00:00 瞬间爆发，前几秒决定生死。
    *   **数据强一致性**：与电商秒杀不同，理财产品涉及资金和监管，**严禁超卖**是最高优先级，必须保证 ACID 特性。
    *   **响应敏感**：用户对“抢不到”可以容忍，但对“转圈等待后告诉失败”容忍度低。

### 2. 【瓶颈识别】
在不做架构优化的情况下，系统会在以下环节崩溃：
*   **核心瓶颈：数据库行锁（Row Lock）**。5万个请求同时更新数据库中同一行（产品剩余额度），数据库TPS只能抗住几百到一千，会导致严重的锁竞争和死锁，瞬间拖垮数据库，甚至波及整个交易系统。
*   **次级瓶颈：应用层带宽与连接数**。5万用户瞬间发起请求，如果应用服务器处理不够快，连接池会被瞬间打满，导致后续请求无法进入。

### 3. 【方案设计】
为了解决上述瓶颈，我们采用**“漏斗型架构”**，层层过滤流量，将数据库隔离在安全区。

#### 第一层：客户端/CDN 拦截（过滤 90% 无效流量）
*   **动静分离**：秒杀页面做静态化处理，推送到 CDN，减少服务器带宽压力。
*   **防抖与置灰**：点击“立即抢购”后按钮立即置灰 3-5 秒，防止用户狂点。
*   **倒计时混淆**：不要完全依赖客户端时间，需与服务器时间同步，且秒杀开始前 URL 动态生成，防止脚本提前刷接口。

#### 第二层：网关层限流（Nginx/Gateway）
*   **全局限流**：设置总 QPS 阈值（例如放行 60,000 请求），超过的直接返回“排队中”或友好提示。
*   **黑名单风控**：识别异常 IP 或高频刷单账号，直接拦截。

#### 第三层：应用层缓存抗压（核心防超卖）
这是最关键的一步，利用 Redis 替代数据库处理扣减逻辑。

*   **技术选型**：Redis（单线程+高性能） + Lua 脚本。
*   **设计理由**：Redis 单机可抗 8-10万 QPS，足以应对 5万并发。Lua 脚本保证了“读取额度”和“扣减额度”的**原子性**，彻底解决超卖问题。
*   **逻辑流程**：
    1.  预先将 100w 额度加载到 Redis。
    2.  请求到达时，执行 Lua 脚本扣减额度。
    3.  扣减成功 -> 视为抢购成功，发放“令牌”，进入下一步。
    4.  扣减失败（额度不足） -> 直接返回“已售罄”。

```lua
-- Redis Lua 伪代码示例
local key = KEYS[1]
local amount = tonumber(ARGV[1])
local current = tonumber(redis.call('get', key))

if current and current >= amount then
    redis.call('decrby', key, amount)
    return 1 -- 成功
else
    return 0 -- 失败
end
```

#### 第四层：异步削峰（MQ）
*   **解耦**：Redis 扣减成功后，并不直接写数据库，而是发送一条“订单创建消息”到消息队列（如 RocketMQ 或 Kafka）。
*   **削峰**：数据库按照自己的处理能力（如每秒处理 2000 单）慢慢消费消息，将 5 万的瞬时流量拉平成几秒甚至几十秒的稳定写入。

#### 第五层：数据库层（最终落地）
*   **事务落库**：消费者收到消息后，在数据库执行真正的资金冻结和订单创建。
*   **乐观锁兜底**：虽然 Redis 挡住了绝大多数并发，但在数据库层面仍建议加上版本号或条件更新作为最后一道防线：
    `UPDATE products SET stock = stock - 1 WHERE id = 1 AND stock > 0;`

### 4. 【兜底策略】
*   **降级开关**：如果 Redis 挂了，立刻切断秒杀入口，显示“系统维护中”或“已售罄”，绝对不能让流量穿透到数据库。
*   **数据对账**：秒杀结束后，通过定时任务对比 Redis 中的扣减记录和数据库的实际订单，确保资金分毫不差。
*   **前端静态兜底**：如果后端服务全挂，CDN 层面直接切换为静态的“活动结束”页面。